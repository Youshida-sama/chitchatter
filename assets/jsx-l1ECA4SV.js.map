{"version":3,"file":"jsx-l1ECA4SV.js","sources":["../../node_modules/refractor/lang/jsx.js"],"sourcesContent":["// @ts-nocheck\n/**\n * @import {Refractor} from '../lib/core.js'\n */\nimport refractorJavascript from './javascript.js'\nimport refractorMarkup from './markup.js'\njsx.displayName = 'jsx'\njsx.aliases = []\n\n/** @param {Refractor} Prism */\nexport default function jsx(Prism) {\n  Prism.register(refractorJavascript)\n  Prism.register(refractorMarkup)\n  ;(function (Prism) {\n    var javascript = Prism.util.clone(Prism.languages.javascript)\n    var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source\n    var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source\n    var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source\n\n    /**\n     * @param {string} source\n     * @param {string} [flags]\n     */\n    function re(source, flags) {\n      source = source\n        .replace(/<S>/g, function () {\n          return space\n        })\n        .replace(/<BRACES>/g, function () {\n          return braces\n        })\n        .replace(/<SPREAD>/g, function () {\n          return spread\n        })\n      return RegExp(source, flags)\n    }\n    spread = re(spread).source\n    Prism.languages.jsx = Prism.languages.extend('markup', javascript)\n    Prism.languages.jsx.tag.pattern = re(\n      /<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/\n        .source\n    )\n    Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/\n    Prism.languages.jsx.tag.inside['attr-value'].pattern =\n      /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/\n    Prism.languages.jsx.tag.inside['tag'].inside['class-name'] =\n      /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/\n    Prism.languages.jsx.tag.inside['comment'] = javascript['comment']\n    Prism.languages.insertBefore(\n      'inside',\n      'attr-name',\n      {\n        spread: {\n          pattern: re(/<SPREAD>/.source),\n          inside: Prism.languages.jsx\n        }\n      },\n      Prism.languages.jsx.tag\n    )\n    Prism.languages.insertBefore(\n      'inside',\n      'special-attr',\n      {\n        script: {\n          // Allow for two levels of nesting\n          pattern: re(/=<BRACES>/.source),\n          alias: 'language-javascript',\n          inside: {\n            'script-punctuation': {\n              pattern: /^=(?=\\{)/,\n              alias: 'punctuation'\n            },\n            rest: Prism.languages.jsx\n          }\n        }\n      },\n      Prism.languages.jsx.tag\n    )\n\n    // The following will handle plain text inside tags\n    var stringifyToken = function (token) {\n      if (!token) {\n        return ''\n      }\n      if (typeof token === 'string') {\n        return token\n      }\n      if (typeof token.content === 'string') {\n        return token.content\n      }\n      return token.content.map(stringifyToken).join('')\n    }\n    var walkTokens = function (tokens) {\n      var openedTags = []\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]\n        var notTagNorBrace = false\n        if (typeof token !== 'string') {\n          if (\n            token.type === 'tag' &&\n            token.content[0] &&\n            token.content[0].type === 'tag'\n          ) {\n            // We found a tag, now find its kind\n\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (\n                openedTags.length > 0 &&\n                openedTags[openedTags.length - 1].tagName ===\n                  stringifyToken(token.content[0].content[1])\n              ) {\n                // Pop matching opening tag\n                openedTags.pop()\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {\n                // Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                })\n              }\n            }\n          } else if (\n            openedTags.length > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '{'\n          ) {\n            // Here we might have entered a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces++\n          } else if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '}'\n          ) {\n            // Here we might have left a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces--\n          } else {\n            notTagNorBrace = true\n          }\n        }\n        if (notTagNorBrace || typeof token === 'string') {\n          if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces === 0\n          ) {\n            // Here we are inside a tag, and not inside a JSX context.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token)\n\n            // And merge text with adjacent text\n            if (\n              i < tokens.length - 1 &&\n              (typeof tokens[i + 1] === 'string' ||\n                tokens[i + 1].type === 'plain-text')\n            ) {\n              plainText += stringifyToken(tokens[i + 1])\n              tokens.splice(i + 1, 1)\n            }\n            if (\n              i > 0 &&\n              (typeof tokens[i - 1] === 'string' ||\n                tokens[i - 1].type === 'plain-text')\n            ) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText\n              tokens.splice(i - 1, 1)\n              i--\n            }\n            tokens[i] = new Prism.Token(\n              'plain-text',\n              plainText,\n              null,\n              plainText\n            )\n          }\n        }\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content)\n        }\n      }\n    }\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'jsx' && env.language !== 'tsx') {\n        return\n      }\n      walkTokens(env.tokens)\n    })\n  })(Prism)\n}\n"],"names":["jsx","Prism","refractorJavascript","refractorMarkup","javascript","space","braces","spread","re","source","flags","stringifyToken","token","walkTokens","tokens","openedTags","i","notTagNorBrace","plainText","env"],"mappings":"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","x_google_ignoreList":[0]}